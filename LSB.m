classdef LSB
    properties
        
        carrier_freq
        m
        sample_rate
        duration
        num_iq_samples
        iq_data
        endPoint
        startPoint
        frame
        bandwidth
    end
    methods
        %% 构造函数
        function self = LSB(sample_rate,carrier_freq,num_iq_samples,bandwidth)
            self.sample_rate = sample_rate;
            self.carrier_freq = carrier_freq;

            self.num_iq_samples = num_iq_samples;
            self.duration = num_iq_samples/self.sample_rate;
            self.bandwidth = bandwidth;
        end
        %% 生成随机数
        function rand_u = rand_uniform(self,low,high)
            rand_u = low + (high-low)*rand;
        end
        %% 生成随机数
        function Hd = getFilter(self,Fpass)
            %GETFILTER Returns a discrete-time filter System object.
            
            % MATLAB Code
            % Generated by MATLAB(R) 9.14 and DSP System Toolbox 9.16.
            % Generated on: 24-Mar-2024 11:02:03
            
            %Fpass = 250000000;   % Passband Frequency
            Fstop = Fpass*1.05;   % Stopband Frequency
            Apass = 1;           % Passband Ripple (dB)
            Astop = 100;          % Stopband Attenuation (dB)
            Fs    = self.sample_rate;  % Sampling Frequency
            
            h = fdesign.lowpass('fp,fst,ap,ast', Fpass, Fstop, Apass, Astop, Fs);
            
            Hd = design(h, 'cheby1', ...
                'MatchExactly', 'passband', ...
                'SystemObject', true,...
                UseLegacyBiquadFilter=true);
        end
       %%
       function [x] = f1_noise(self,N_)
            if mod(N_,2)>0
                N=(N_-1)/2;
            else
                N=N_/2;
            end
           f = linspace(0.1, self.bandwidth, N);
            % 生成1/f^beta功率谱密度
            beta = 1.6; % 可以调整beta以改变1/f特性
            S = 1 ./ f.^beta;
            % 将功率谱密度限制在带宽范围内
            S(f < 0.1 | f > 0.1 + self.bandwidth) = 0;
            % 在频域中生成复数随机数，其幅度为S的平方根，相位随机
            X = sqrt(S) .* exp(1i * 2 * pi * rand(1, N));
            
            % 对频谱进行合成
            x = ifft(X, 'symmetric');
            
            % 归一化
            x = x - mean(x);
            x = x / std(x);
            if mod(N_,2)>0
                x = [fliplr(x),0,x];
            else
                x = [fliplr(x),x];
            end
            
            x = x';
       end
       %% 主函数
       function self = call(self)
            t = linspace(0,self.num_iq_samples/self.sample_rate,self.num_iq_samples);
            carrier = exp(1i*2*pi*self.carrier_freq*t');
            %message-rand
            % message_ = abs(randn(self.num_iq_samples,1))-1j*abs(randn(self.num_iq_samples,1));%randn(self.num_iq_samples,1,"like",1i);
            message_ = self.f1_noise(self.num_iq_samples);
            Hd = self.getFilter(self.bandwidth);
            message_ = Hd(message_);
            f_message_ = (fft(message_));%fftshift(fft(message_));
            
            if self.carrier_freq<0
                f_message_(floor(max(size(f_message_)))/2:max(size(f_message_)),:)=0;
            else
                f_message_(1:floor(max(size(f_message_)))/2,:)=0;
            end
            message_=ifft(f_message_);

            
            self.frame = (message_).*carrier;
            

            self.iq_data = zeros(self.num_iq_samples,1);
            self.frame = conj(self.frame');
            % Hd = self.getFilter(abs(self.bandwidth));
            % message_ = Hd(message_);
            % 
            % Fpass = self.carrier_freq;
            % Hd = self.getFilter(abs(Fpass));
            % 
            % self.frame = message_.*carrier;
            % self.frame = Hd(self.frame);
            % 
            % self.iq_data = zeros(1,self.num_iq_samples);
            % self.frame = conj(self.frame)';

            position = randi([0,2]);
            tmp_time_domain = zeros(self.num_iq_samples,1);
            if max(size(self.frame)) >= self.num_iq_samples % 如果信号长度大于一帧的长度
                if position == 0
                    self.startPoint = randi([0,ceil(self.num_iq_samples*0.5)]);
                    tmp_time_domain(self.startPoint:self.num_iq_samples,:) = self.frame(:,self.startPoint:self.num_iq_samples);
                    self.frame = tmp_time_domain;
                    self.endPoint = self.num_iq_samples;
                elseif position == 1
                    % self.startPoint = randi([0,(size(self.frame,1)-self.num_iq_samples)]); % 信号截取的位置
                    % self.frame = self.frame(self.startPoint:self.num_iq_samples+self.startPoint-1,:);
                    self.startPoint = 1;self.endPoint = self.num_iq_samples;
                else
                    self.endPoint = randi([0,ceil(self.num_iq_samples*0.5)]); % 信号截取的位置
                    tmp_time_domain(1:self.endPoint,:) = self.frame(:,size(self.frame,2)-self.endPoint+1:size(self.frame,2));
                    self.frame = tmp_time_domain;
                    self.startPoint = 1;
                end

            else % 如果信号长度小于一帧的长度
                tmp = floor((self.num_iq_samples-size(self.frame,1))/2);
                self.startPoint = ceil(self.rand_uniform(0,tmp)); % 信号截取的位置
                tmp = zeros(self.num_iq_samples,1);
                if self.startPoint+size(self.frame,1) <= self.num_iq_samples
                    tmp(self.startPoint:self.startPoint+max(size(self.frame))-1,:) = self.frame;
                    self.endPoint = self.startPoint+size(self.frame,1);
                else
                    tmp(self.startPoint:self.num_iq_samples-1,1:size(tmp,2)) = iqdata(1:self.num_iq_samples-self.startPoint);
                    self.endPoint = self.num_iq_samples;
                end
                self.frame = tmp;
            end
            self.iq_data = self.frame;
            % % % plot(abs(self.iq_data))
       end
    end
end